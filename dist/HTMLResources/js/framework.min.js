(function($) {
    'use strict';
    $ = $ || jQuery;
  
    $(function() {
        //Put your code here
        /*var body = $('body'),
            html = $('html'),
            $doc = $(document);*/

            /*handlexxxxxxxxxx = function () {
              
            };*/


        //$navCloseDropdown.on('click', handlexxxxxxxxxx);

        // Only run this stuff if page is fully loaded
        // This is needed to prevent onreadystatechange being run twice
        var ready = false;

        document.onreadystatechange = function() {

          if (ready) {
            return;
          }
          
          //Put your code here

        };
    });
})(jQuery);
(function() {

	'use strict';

	angular
		.module('quizFramework', ['ngMaterial']);

})();
(function() {

	'use strict';
	
	function ListController(quizMetrics, dataService) {
		// VM = Virtual model
		var vm = this;

		function activateQuiz(){
			quizMetrics.changeState('quiz', true);
		}

		//GIVE ACCESS TO QUIZMETRICS IN LIST CONTROLLER & BIND TO VM
		vm.quizMetrics = quizMetrics;
		//
		vm.data = dataService.JSONQuizData;
		//
		vm.activateQuiz = activateQuiz;
	}

	angular
		.module('quizFramework')
		.controller('listCtrl', ListController);

	ListController.$inject = ['quizMetrics', 'dataService'];

})();
(function() {

	'use strict';

	function QuizController(quizMetrics, dataService) {
		// VM = Virtual model
		var vm = this;
		
		var numQuestionsAnswered = 0;

		//if the back button is clicked determine if we can go back and hide the button accordingly
		function backQuestion(){
			//if the previous question hasn't been answered - prevents click on progress showing unwanted back link
			if(vm.activeQuestion < 1){
				vm.back = false;
				vm.feedback = false;
			} else {
				//if we click the progress bar and the previous question hasn't been answered and the answer screen is not in view
				if(dataService.JSONQuizData[vm.activeQuestion].selected === null && vm.feedback ===false){
					vm.activeQuestion--;
					vm.feedback = false;
				} else {
						//First question so hide the back button
						if(vm.activeQuestion < 1){
							vm.back = false;
						} else {
								//go back to the question screen
								if(vm.feedback === true){									
									vm.feedback = false;
									vm.activeQuestion--;
								}
								//go back to the answer screen
								else {								
									vm.feedback = true;
									vm.activeQuestion--;
								}
						}
				}
			}
		}

		//if this function is running then not all questions have been answered so go to the next unanswered question
		function setActiveQuestion(index){
			vm.feedback = false;

			if(index === undefined){
				var breakOut = false;
				//Take one off the length to match number of questions, array starts at 0
				var quizLength = dataService.JSONQuizData.length - 1;

				while(!breakOut){
					//If active question is less than the length of the quiz then increment active question
					vm.activeQuestion = vm.activeQuestion < quizLength?++vm.activeQuestion:0;

					//Error if not all questions answered
					if(vm.activeQuestion === 0){
						vm.error = true;
					}

					//If the active question hasn't yet been answered then we have found the next unanswered question
					if(dataService.JSONQuizData[vm.activeQuestion].selected === null){
						breakOut = true;
					}
				}
			} else {
				vm.activeQuestion = index;
			}

		}

		//if user has clicked submit answer
		function questionAnswered(){
			vm.feedback = true;
			vm.back = true;
		}

		//if user has clicked continue in the answer feedback screen
		function questionContinue(){

			vm.feedback = false;

			var quizLength = dataService.JSONQuizData.length;

			//If the current question has been answered increment the number of total questions
			if(dataService.JSONQuizData[vm.activeQuestion].selected !== null){
				numQuestionsAnswered++;
				if(numQuestionsAnswered >= quizLength){
					//finish quiz
					for(var i = 0; i < quizLength; i++){
						if(dataService.JSONQuizData[i].selected === null){
							setActiveQuestion(i);
							return;
						}
					}
					vm.error = false;
					vm.finalise = true;
					return;
				}

				//If we are on the last question swap the next question button to a find out score button
				if(numQuestionsAnswered === quizLength - 1){
					vm.lastQuestion = true;
				}

			}

			vm.setActiveQuestion();
		}

		//Set the selected answer to the index of the question
		function selectAnswer(index){
			dataService.JSONQuizData[vm.activeQuestion].selected = index;

			/*var selectedAnswer = dataService.JSONQuizData[vm.activeQuestion].selected = index;
			selectedAnswer = index;

			vm.answerArray.push(selectedAnswer);
			window.alert(vm.answerArray);*/
		}

		//Reset everything
		function finaliseAnswers(){
			vm.finalise = false;
			vm.back = false;
			vm.lastQuestion = false;
			numQuestionsAnswered = 0;
			vm.activeQuestion = 0;
			quizMetrics.markQuiz();
			quizMetrics.reviewQuiz();
			quizMetrics.changeState('quiz', false);
			//trigger the results page
			quizMetrics.changeState('results', true);
		}

		//GIVE ACCESS TO QUIZMETRICS IN QUIZ CONTROLLER & BIND TO VM
		vm.quizMetrics = quizMetrics;
		//Get access to dataService object in our view
		vm.dataService = dataService;
		//Named function syntax
		vm.questionAnswered = questionAnswered;
		//Show the feedback for the question
		vm.questionContinue = questionContinue;
		//Set the active question
		vm.setActiveQuestion = setActiveQuestion;
		//Go back a question
		vm.backQuestion = backQuestion;
		//Set the selected question
		vm.selectAnswer = selectAnswer;
		//Finalise answers
		vm.finaliseAnswers = finaliseAnswers;
		//Set the starting question
		vm.activeQuestion = 0;
		//Basic error handling if not all questions have been answered
		vm.error = false;
		//Displays a prompt to check if user wants to go to the results page
		vm.finalise = false;
		//Displays the feedback to the answer
		vm.feedback = false;
		//Switch the button in the last answer screen
		vm.lastQuestion = false;
		//Back link after first question answered
		vm.back = false;

	}

	angular
		.module('quizFramework')
		.controller('quizCtrl', QuizController)
		.filter('character',function(){
	    return function(input){
	        return String.fromCharCode(64 + parseInt(input,10));
	    };
		});

	QuizController.$inject = ['quizMetrics', 'dataService'];

})();
(function() {

	'use strict';

	function ResultsController(quizMetrics, dataService) {

		// VM = Virtual model
		var vm = this;

		//Show score feedback tagline
		function calculateScoreTagline(){
			//Loop through all questions in JSON and match score to description
			for(var i = 0; i < dataService.JSONScoreDescription.length; i++){
				var score = quizMetrics.numCorrect,
						matchedScore = dataService.JSONScoreDescription[i].score;

				if(score === matchedScore){
					//do something
					return dataService.JSONScoreDescription[i].tagline;
				}
			}
		}

		//Show score feedback description
		function calculateScoreDescription(){
			//Loop through all questions in JSON and match score to description
			for(var i = 0; i < dataService.JSONScoreDescription.length; i++){
				var score = quizMetrics.numCorrect,
						matchedScore = dataService.JSONScoreDescription[i].score;

				if(score === matchedScore){
					//do something
					return dataService.JSONScoreDescription[i].description;
				}
			}
		}

		//calculate the number of each question answered to determine final output
		function calculateDiagnosticScore(){
			//Loop through all questions in JSON and match score to diagnostic score
			var score = quizMetrics.answerArray;
			var numberOfQuestions = [];
			var matches = [];

			for (var i = 0; i < dataService.JSONDiagnosticResult.length; i++) {
				var matchedScore = dataService.JSONDiagnosticResult[i].score;
				numberOfQuestions.push(matchedScore);

				//console.log(numberOfQuestions);

				for(var j = 0; j < score.length; j++){
	        
	        //If more than one score in the array then we have a tied score
					if(score.length >= 2){
						//console.log('MORE THAN 1');

						//Show the last item in the JSON file
						i = dataService.JSONDiagnosticResult.length -1;

						return dataService.JSONDiagnosticResult[i].title,
									 dataService.JSONDiagnosticResult[i].image,
									 dataService.JSONDiagnosticResult[i].description;
					}

					//Else determine which final result to display
	        else if(numberOfQuestions[i] === score[j]){
	            matches.push(numberOfQuestions[i]);

	            //console.log(score);

	            return dataService.JSONDiagnosticResult[i].title,
										 dataService.JSONDiagnosticResult[i].image,
										 dataService.JSONDiagnosticResult[i].description;
	        }
	    	}

			}
		}

		//Show score percentage
		function calculatePerc(){
			return quizMetrics.numCorrect / dataService.JSONQuizData.length * 100;
		}

		//Show question of clicked legend link
		function setActiveQuestion(index){
			vm.activeQuestion = index;
		}

		//Set the class of the answer - corrrect or incorrect
		function getAnswerClass(index){
			//if index is the same as the correct answers index return class to display
			if(index === dataService.JSONCorrectAnswers[vm.activeQuestion].number){
				//if correct
				return 'bg-success';
			} else if(index === dataService.JSONQuizData[vm.activeQuestion].selected){
				//if incorrect
				return 'bg-danger';
			}
		}

		function reset(){
			quizMetrics.changeState('results', false); 
			//Reset the number of question corrects as we are startin again.
			quizMetrics.numCorrect = 0;
			quizMetrics.answerCount = null;
			quizMetrics.answerArray = [];
			quizMetrics.answermax = null,
			quizMetrics.answerResult = {},
			quizMetrics.duplicateResults = [];

			//Loop through all questions in JSON and reset all flags back to default
			for(var i = 0; i < dataService.JSONQuizData.length; i++){
				var data = dataService.JSONQuizData[i];

				data.selected = null;
				data.correct = null;
			}
		}

		vm.quizMetrics = quizMetrics;
		vm.dataService = dataService;
		vm.getAnswerClass = getAnswerClass;
		vm.reset = reset;
		vm.setActiveQuestion = setActiveQuestion;
		vm.calculatePerc = calculatePerc;
		vm.calculateScoreTagline = calculateScoreTagline;
		vm.calculateScoreDescription = calculateScoreDescription;
		vm.calculateDiagnosticScore = calculateDiagnosticScore;
		vm.activeQuestion = 0;

	}

	angular
		.module('quizFramework')
		.controller('resultsCtrl', ResultsController);

	ResultsController.$inject = ['quizMetrics', 'dataService'];

})();
(function() {

	'use strict';

	function DataFactory($http) {

		/*var urlBase = 'http://www.json-generator.com/api/json/get/bQkWdPSKMi?indent=2';*/
		var urlBase = 'HTMLResources/json/quiz-data.json?callback=JSON_CALLBACK';

		var JSONQuizData = [];
		var JSONCorrectAnswers = [];
		var JSONScoreDescription = [];
		var JSONDiagnosticResult = [];

		var dataObj = {
			JSONQuizData: JSONQuizData,
			JSONCorrectAnswers: JSONCorrectAnswers,
			JSONScoreDescription: JSONScoreDescription,
			JSONDiagnosticResult: JSONDiagnosticResult
		};

    $http.get(urlBase).success(function(data) {
        dataObj.JSONQuizData = data.JSONQuizData,
        dataObj.JSONCorrectAnswers = data.JSONCorrectAnswers,
        dataObj.JSONScoreDescription = data.JSONScoreDescription,
        dataObj.JSONDiagnosticResult = data.JSONDiagnosticResult;
    });

  	return dataObj;
	}

	angular
		.module('quizFramework')
		.factory('dataService', DataFactory);

	DataFactory.$inject = ['$http'];
		
})();
(function() {

	'use strict';

	function QuizMetrics(dataService) {

		function changeState(metric, state){
			if(metric === 'quiz'){
				quizObj.quizActive = state;
			} else if(metric === 'results') {
				quizObj.resultsActive = state;
			} else {
				return false;
			}		
		}

		//Count duplicate values and push into empty array
	  function finaliseResult(){

	  	quizObj.answerArray = [];

			for (var key in quizObj.duplicateResults) {
			    if (quizObj.duplicateResults.hasOwnProperty(key)) {
			      quizObj.answerArray.push(parseInt(quizObj.duplicateResults[key]));
			    }
			}

			//console.log(quizObj.answerArray);
	  }

		//Count each answer type
		function countAnswers() {

			for(var i = 0; i < quizObj.answerArray.length; ++i) {
			    if(!quizObj.answerResult[quizObj.answerArray[i]]) {
			    	quizObj.answerResult[quizObj.answerArray[i]] = 0;
			    }
			    ++quizObj.answerResult[quizObj.answerArray[i]];

			    /*if(!quizObj.answerResult[quizObj.answerArray[i]]) 
			        quizObj.answerResult[quizObj.answerArray[i]] = 0;
			    ++quizObj.answerResult[quizObj.answerArray[i]];*/
			}

			//Find the highest value in the results array
			quizObj.answermax = Math.max.apply(null,Object.keys(quizObj.answerResult).map(function(x){ return quizObj.answerResult[x]; }));
			
			//Filter duplicate results
			quizObj.duplicateResults = Object.keys(quizObj.answerResult).filter(function(x){ return quizObj.answerResult[x] == quizObj.answermax; });

			//console.log(quizObj.answerResult);
			//console.log(quizObj.duplicateResults);
			//console.log(quizObj.answermax);

			finaliseResult();

	  }

		//Mark the answers
		function markQuiz(){

			quizObj.JSONCorrectAnswers = dataService.JSONCorrectAnswers;
			//Loop through questions and check answer given by the user
			for(var i = 0; i < dataService.JSONQuizData.length; i++){
				if(dataService.JSONQuizData[i].selected === dataService.JSONCorrectAnswers[i].number){
					//set correct flag on answer						
					dataService.JSONQuizData[i].correct = true;
					quizObj.numCorrect++;
				} else {
					//set incorrect flag on answer
					dataService.JSONQuizData[i].correct = false;
				}
			}
		}

		//Collate the answers
		function reviewQuiz(){
			for(var i = 0; i < dataService.JSONQuizData.length; i++){
	    	quizObj.answerArray.push(dataService.JSONQuizData[i].selected);

	    	//console.log(quizObj.answerArray);
		  }

		  countAnswers();
		}


		var quizObj = {
			quizActive: false,
			resultsActive: false,
			changeState: changeState,
			JSONCorrectAnswers: [],
			answerArray: [],
			markQuiz: markQuiz,
			reviewQuiz: reviewQuiz,
			numCorrect: 0,
			answermax: null,
			answerResult: {},
			duplicateResults: []
		};

		return quizObj;

	}

	angular
		.module('quizFramework')
		.factory('quizMetrics', QuizMetrics);

	QuizMetrics.$inject = ['dataService'];
		
})();
//# sourceMappingURL=framework.min.js.map
